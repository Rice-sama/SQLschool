options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
}

PARSER_BEGIN(ParserSQL)
package apprendreSQL.Model;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.List;
import java.util.ArrayList;



public  class ParserSQL {
}

PARSER_END(ParserSQL)

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\f"
|   "\r"
}

/* Comments */
SPECIAL_TOKEN :
{
    <LINE_COMMENT: "--" (~["\n"])* "\n">
}

MORE :
{
    "/*": IN_BLOCK_COMMENT
}

<IN_BLOCK_COMMENT> MORE :
{
    <~[]>
}

<IN_BLOCK_COMMENT> SPECIAL_TOKEN :
{
    <BLOCK_COMMENT: "*/">: DEFAULT
}



/* Keywords */
TOKEN :
{
    <ABORT: "ABORT">
|   <ACTION: "ACTION">
|   <ADD: "ADD">
|   <AFTER: "AFTER">
|   <ALL: "ALL">
|   <ALTER: "ALTER">
|   <ANALYZE: "ANALYZE">
|   <AND: "AND">
|   <AS: "AS">
|   <ASC: "ASC">
|   < OLD:"old" >
|   <ATTACH: "ATTACH">
|   <AUTOINCREMENT: "AUTOINCREMENT">
|   <BEFORE: "BEFORE">
|   <BEGIN: "BEGIN">
|   <BETWEEN: "BETWEEN">
|   <BY: "BY">
|   <CASCADE: "CASCADE">
|   <CASE: "CASE">
|   <CAST: "CAST">
|   <CHECK: "CHECK">
|   <COLLATE: "COLLATE">
|   <COLUMN: "COLUMN">
|   <COMMIT: "COMMIT">
|   <CONFLICT: "CONFLICT">
|   <CONSTRAINT: "CONSTRAINT">
|   <CREATE: "CREATE">
|   <CROSS: "CROSS">
|   <CURRENT_DATE: "CURRENT_DATE">
|   <CURRENT_TIME: "CURRENT_TIME">
|   <CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP">
|   <DATABASE: "DATABASE">
|   <DEFAULT_: "DEFAULT">
|   <DEFERRABLE: "DEFERRABLE">
|   <DEFERRED: "DEFERRED">
|   <DELETE: "DELETE">
|   <DESC: "DESC">
|   <DETACH: "DETACH">
|   <DISTINCT: "DISTINCT">
|   <DROP: "DROP">
|   <EACH: "EACH">
|   <ELSE: "ELSE">
|   <END: "END">
|   <ESCAPE: "ESCAPE">
|   <EXCEPT: "EXCEPT">
|   <EXCLUSIVE: "EXCLUSIVE">
|   <EXISTS: "EXISTS">
|   <EXPLAIN: "EXPLAIN">
|   <FAIL: "FAIL">
|   <FOR: "FOR">
|   <FOREIGN: "FOREIGN">
|   <FROM: "FROM">
|   <FULL: "FULL">
|   <GLOB: "GLOB">
|   <GROUP: "GROUP">
|   <HAVING: "HAVING">
|   <IF: "IF">
|   <IGNORE: "IGNORE">
|   <IMMEDIATE: "IMMEDIATE">
|   <IN: "IN">
|   <INDEX: "INDEX">
|   <INDEXED: "INDEXED">
|   <INITIALLY: "INITIALLY">
|   <INNER: "INNER">
|   <INSERT: "INSERT">
|   <INSTEAD: "INSTEAD">
|   <INTERSECT: "INTERSECT">
|   <INTO: "INTO">
|   <IS: "IS">
|   <ISNULL: "ISNULL">
|   <JOIN: "JOIN">
|   <KEY: "KEY">
|   <LEFT: "LEFT">
|   <LIKE: "LIKE">
|   <LIMIT: "LIMIT">
|   <MATCH: "MATCH">
|   <NATURAL: "NATURAL">
|   <NO: "NO">
|   <NOT: "NOT">
|   <NOTNULL: "NOTNULL">
|   <NULL: "NULL">
|   <OF: "OF">
|   <OFFSET: "OFFSET">
|   <ON: "ON">
|   <OR: "OR">
|   <ORDER: "ORDER">
|   <OUTER: "OUTER">
|   <PLAN: "PLAN">
|   <PRAGMA: "PRAGMA">
|   <PRIMARY: "PRIMARY">
|   <QUERY: "QUERY">
|   <RAISE: "RAISE">
|   <REFERENCES: "REFERENCES">
|   <REGEXP: "REGEXP">
|   <REINDEX: "REINDEX">
|   <RELEASE: "RELEASE">
|   <RENAME: "RENAME">
|   <REPLACE: "REPLACE">
|   <RESTRICT: "RESTRICT">
|   <RIGHT: "RIGHT">
|   <ROLLBACK: "ROLLBACK">
|   <ROW: "ROW">
|   <SAVEPOINT: "SAVEPOINT">
|   <SELECT: "SELECT">
|   <SET: "SET">
|   <TABLE: "TABLE">
|   <TEMP: "TEMP">
|   <TEMPORARY: "TEMPORARY">
|   <THEN: "THEN">
|   <TO: "TO">
|   <TRANSACTION: "TRANSACTION">
|   <TRIGGER: "TRIGGER">
|   <UNION: "UNION">
|   <UNIQUE: "UNIQUE">
|   <UPDATE: "UPDATE">
|   <USING: "USING">
|   <VACUUM: "VACUUM">
|   <VALUES: "VALUES">
|   <VIEW: "VIEW">
|   <VIRTUAL: "VIRTUAL">
|   <WHEN: "WHEN">
|   <WHERE: "WHERE">
}

/* Operators */
TOKEN :
{
    <CONCATENATION: "||">
|   <STAR: "*">
|   <SLASH: "/">
|   <MODULO: "%">
|   <PLUS: "+">
|   <MINUS: "-">
|   <SHIFT_HIGH: "<<">
|   <SHIFT_LOW: ">>">
|   <BIT_AND: "&">
|   <BIT_OR: "|">
|   <BIT_NOT: "~">
|   <LESS: "<">
|   <LESS_OR_EQUAL: "<=">
|   <GREATER: ">">
|   <GREATER_OR_EQUAL: ">=">
|   <EQUAL_1: "=">
|   <EQUAL_2: "==">
|   <NOT_EQUAL_1: "!=">
|   <NOT_EQUAL_2: "<>">
}

/* Literals & Identifiers */
TOKEN :
{
    <NUMERIC:
        (
            (<DIGIT>)+ (<DOT> (<DIGIT>)*)?
        |   <DOT> (<DIGIT>)+
        )
        (<EXPONENT>)?
    >
|   <#EXPONENT: "E" (["+", "-"])? (<DIGIT>)+>
|   <STRING: "'" (~["'"])* ("''" (~["'"])*)* "'">
|   <BLOB: "X'" (<HEX_CHAR> <HEX_CHAR>)* "'">
|   <PARAMETER: 
        "?" (<DIGIT>)*
    |   (":" | "@" | "$") // sqlite implementation also allows '#'.
        ("::")?
        <CHAR>
        (<CHAR> | "::")*
        (
            "("
            (~[")", "\t", "\n", "\f", "\r", " "])*
            ")"
        )?
    >
|   <ID: 
        <CHAR> (<CHAR> | <DIGIT>)*
    |   "\"" (~["\""])* ("\"\"" (~["\""])*)* "\""
    |   "`" (~["`"])* ("``" (~["`"])*)* "`"
    |   "[" (~["]"])* "]"
    >
}

/* Separators */
TOKEN :
{
    <LP: "(">
|   <RP: ")">
|   <SEMICOLON: ";">
|   <COMMA: ",">
|   <DOT: ".">
}

/* Char Sets */
TOKEN :
{
    <#DIGIT: ["0" - "9"]>
    // Has mentioned in sqlite implementation '$' is not documented but is implemented for
    // compatibility.
|   <#CHAR: ["A" - "Z", "_", "$"]>
|   <#HEX_CHAR: ["0" - "9", "A" - "F"]>
}

/* Grammar */
void sqlStmtList() :
{}
{
     sqlStmt() ";"
}

void sqlStmt() :
{}
{
    [   
        "EXPLAIN" 
        [ "QUERY" "PLAN" ] 
    ]
    (
         alterTableStmt()
    |    analyzeStmt()
    |     attachStmt()
	|      beginStmt()
	|      commitStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
          createIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
           createTableStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
            createTriggerStmt()
	|   LOOKAHEAD(2) // Decide what type of CREATE is being parsed.
          createViewStmt()
	|    createVirtualTableStmt()
	|    deleteStmt()
	|    detachStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
	    dropIndexStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        dropTableStmt()
	|   LOOKAHEAD(2) // Decide what type of DROP is being parsed.
        dropTriggerStmt()
	|   dropViewStmt()
	|   insertStmt()
	|   pragmaStmt()
	|   reindexStmt()
	|   releaseStmt()
	|   rollbackStmt()
	|   savepointStmt()
	|   selectStmt()
	|   updateStmt()
	|   vacuumStmt()
    )
}

void name() :
{
}
{
    (
          <ID>
    |   <STRING>
    ) 
}

void alterTableStmt() :
{}
{
    "ALTER"  "TABLE"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
     name()
    (
      renameTableStmt()
    | addColumnStmt()
    ) 
}

void renameTableStmt() :
{}
{
    "RENAME" "TO" name() 
}

void addColumnStmt() :
{}
{
    "ADD"
    [
    	"COLUMN" 
	]
   columnDef() 
}

void analyzeStmt() :
{}
{
    "ANALYZE"
    [
        name()
        [
            "."  name()
        ]
    ]
}

void attachStmt() :
{}
{
    "ATTACH" 
    [
        "DATABASE" 
    ]
    expr() "AS"  name() 
}

void beginStmt() :
{}
{
    "BEGIN" 
    [
        "DEFERRED" 
    |   "IMMEDIATE" 
    |   "EXCLUSIVE" 
    ]
    [
        "TRANSACTION" 
    ] 
}

void commitStmt() :
{}
{
    (
        "COMMIT"
    |   "END" 
    ) 
    [
        "TRANSACTION" 
    ]
 }

void rollbackStmt() :
{}
{
    "ROLLBACK"
        [
    	"TRANSACTION" 
		]
    [
        "TO"
        [
        	"SAVEPOINT"	
        ]
        	 name()
    ]
}

void savepointStmt() :
{}
{
    "SAVEPOINT"  name() 
}

void releaseStmt() :
{}
{
    "RELEASE" 
    [
    	"SAVEPOINT"	
	]
     name()
}

void createIndexStmt() :
{}
{
    "CREATE" 
    [
        "UNIQUE" 
    ]
    "INDEX"
    [
        "IF" "NOT" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
    name()"ON"
    name()
    "("
   		indexedColumn() 
    (
        ","
	    indexedColumn() 
    )*
    ")" 
}

void indexedColumn() :
{}
{
    name()
    [
        "COLLATE"  name()
    ]
    [
        "ASC" 
    |   "DESC" 
    ]
  }

void createTableStmt() :
{}
{
    "CREATE" 
    [
        ("TEMP" | "TEMPORARY") 
    ]
    "TABLE"
    [
        "IF" "NOT" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
     name()
    (
         createTableStmtWithColumns()
    |   createTableStmtWithSelect()
    ) 
}

void createTableStmtWithColumns() :
{}
{
    "("  columnDef()
    // As the two next expressions start by "," it's necessary to use 
    // LOOKAHEAD(2) to decide if we're seeing a column definition or a table
    // constraint.
    (
        LOOKAHEAD(2)
        ","
       	columnDef() 
    )* 
    (   
        "," 
     tableConstraint() 
    )*
    ")" 
}

void createTableStmtWithSelect() :
{}
{
    "AS"  selectStmt()
}

void columnDef() :
{}
{
   name() 
    [
    	typeName()
    ]
    (
        columnConstraint() 
    )*
}

void typeName() :
{}
{
    name() 
    (
        name() 
    )*
    [
        "("
      signedNumber()
        [
            ","
         signedNumber()
        ]
        ")"
    ]
}

void columnConstraint() :
{}
{
    [
        "CONSTRAINT"  name()
    ]
    (
        primaryKeyColumnConstraint()
    |   notNullColumnConstraint()
    |   uniqueColumnConstraint()
    |   checkColumnConstraint()
    |   defaultColumnConstraint()
    |   collateColumnConstraint()
    |   foreignKeyColumnConstraint()
    ) 
}

void primaryKeyColumnConstraint() :
{}
{
    "PRIMARY" "KEY" 
    [
        "ASC"
    |   "DESC" 
    ]
     conflictClause()
    [
        "AUTOINCREMENT" 
    ]
}

void notNullColumnConstraint() :
{}
{
    "NOT" "NULL"  conflictClause()
}

void uniqueColumnConstraint() :
{}
{
    "UNIQUE" conflictClause() 
}

void checkColumnConstraint() :
{}
{
    "CHECK"  "("  expr() ")" 
}

void defaultColumnConstraint() :
{}
{
    "DEFAULT" 
    (
        // As signedNumber and literalValue match a numericLiteral() it is only
        // consider to exist a signedNumber if actually there is sign.
        LOOKAHEAD("+" | "-")
         signedNumber()
    |    literalValue() 
    |   "("
         expr()
        ")"
    )
    }

void collateColumnConstraint() :
{}
{
    "COLLATE" name()
}

void foreignKeyColumnConstraint() :
{}
{
    foreignKeyClause()
}

void signedNumber() :
{}
{
    [
        (
            "+"
        |   "-" 
        ) 
    ]
    numericLiteral() 
}

void tableConstraint() :
{}
{
    [
        "CONSTRAINT" 
         name()
    ]
    (
        primaryKeyTableConstraint()
    |   checkTableConstraint()
    |   foreignKeyTableConstraint()
    ) 
}

void primaryKeyTableConstraint() :
{}
{
    "PRIMARY" 
    "KEY"
    "(" indexedColumn() 
    (
        ","
         indexedColumn() 
    )*
    ")"
  	conflictClause() 
}

void uniqueTableConstraint() :
{}
{
    "UNIQUE"
    "(" 
    indexedColumn() 
    (
        ","
         indexedColumn()
    )*
    ")"
 	conflictClause() 	
}

void checkTableConstraint() :
{}
{
    "CHECK"     "("
     expr() 
    ")" 
}

void foreignKeyTableConstraint() :
{
}
{
    "FOREIGN" 
    "KEY"
    "("
     name() 
    (
        "," 
        name() 
    )*
    ")"
   foreignKeyClause() 
}

void foreignKeyClause() :
{}
{
    "REFERENCES" name()
    [
        "("
         name() 
        (
            ","
            name() 
        )*
        ")"
    ]
    (
        onSetting()
    |   matchSetting() 
    )*
    [
        LOOKAHEAD(2) // Ensures that is deferrable because first token can be 
                     // either NOT or DEFERRABLE.
         deferrableSetting() 
    ] 
}

void onSetting() :
{}
{
    "ON"
    (
        "DELETE" 
    |   "UPDATE" 
    )
    (
        "SET"
        (
            "NULL" 
        |   "DEFAULT" 
        )
    |   "CASCADE"
    |   "RESTRICT"
    |   "NO" "ACTION" 
    ) 
}

void matchSetting() :
{}
{
    "MATCH" 
    name() 
}

void deferrableSetting() :
{}
{
    (
        "NOT" 
        "DEFERRABLE"
    |   "DEFERRABLE"
    )
    [
        "INITIALLY"
        (
            "DEFERRED" 
        |   "IMMEDIATE" 
        )
    ] 
}

void conflictClause() :
{}
{
    [   
        "ON"
        "CONFLICT"
        (
            "ROLLBACK"
        |   "ABORT"
        |   "FAIL" 
        |   "IGNORE" 
        |   "REPLACE" 
        ) 
    ] 
}

void createTriggerStmt() :
{}
{
    "CREATE" 
    [
        ("TEMP" | "TEMPORARY")
    ]
    "TRIGGER"
    [
        "IF" "NOT" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() "."
    ]
    	name()
    [
        "BEFORE" 
    |   "AFTER" 
    |   "INSTEAD" "OF" 
    ]
    (
        "DELETE" 
    |   "INSERT"  
    |   "UPDATE"
        [
            "OF" 
            name()
            (
                ","
                name()
            )*
        ]
    )
    "ON"
    name()
    [
        "FOR" "EACH" "ROW"
    ]
    [
        "WHEN"
   		expr()
    ]
    "BEGIN" 
    (
        (
             updateStmt()
        |    insertStmt()
        |    deleteStmt()
        |    selectStmt()
        ) 
        ";"
    )+
    "END" 
}

void createViewStmt() :
{}
{
    "CREATE"
    [
        ("TEMP" | "TEMPORARY") 
    ]
    "VIEW"
    [
        "IF" "NOT" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
 	name()
    "AS"
    selectStmt()
}

void createVirtualTableStmt() :
{}
{
    "CREATE" 
    "VIRTUAL" "TABLE"
    [
        "IF" "NOT" "EXISTS" 
    ]

    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
      name()  "USING"  name()
    [
        "(" moduleArgument() 
        (
            ","
             moduleArgument() 
        )*
        ")"
    ]
}

void moduleArgument() :
{
}
{
    // TODO:
    [
	    "("
        other()
	    ")"
    ] 
}

void other() :
{
}
{
    [
	    "("
        other()
	    ")"
    ]
}

void deleteStmt() :
{}
{
    "DELETE"
    "FROM"
  	qualifiedTableName()
    [
        "WHERE"
         expr()
    ]
    eventConstraint() 
}

void eventConstraint() :
{}
{
    [
        "ORDER" 
        "BY"
         orderingTerm() 
        (
            ","
            orderingTerm() 
        )*
    ]
    [
        "LIMIT"
         expr()
        [
            ( "OFFSET" | "," )
            expr()
        ]
    ] 
}

void detachStmt() :
{}
{
    "DETACH" 
    [
    	"DATABASE" 
    ]
     name() 
}

void dropIndexStmt() :
{}
{
    "DROP" 
    "INDEX"
    [
        "IF" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        name() "."
    ]
        name() 
}

void dropTableStmt() :
{}
{
    "DROP"
    "TABLE"
    [
        "IF" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() "."
    ]
     name() 
}

void dropTriggerStmt() :
{}
{
    "DROP" 
    "TRIGGER"
    [
        "IF" "EXISTS" 
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() "."
    ]
      name() 
}

void dropViewStmt() :
{}
{
    "DROP"
    "VIEW"
    [
        "IF" "EXISTS"
    ]
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() "."
    ]
     name() 
}

// Expression is built by parts recursively to ensure operator precedences are
// to avoid left recursion.
void expr() :
{}
{
     andExpr()   
    (
        "OR"
         andExpr() 
    )* 
}

void andExpr() :
{}
{
     notExpr()
    (
        "AND"
        notExpr() 
    )* 
}

void notExpr() :
{}
{
    (
        "NOT" 
         notExpr() 
    |   equalityExpr() 
    ) 
}

void equalityExpr() :
{}
{
     relationalExpr()
    // All types of expressions in this choice point can start by "NOT". 
    // LOOKAHEAD removes ambiguity which one to choose.
    (
        LOOKAHEAD(2)
         unaryEqualityExpr()
    |   LOOKAHEAD(2)
        betweenExpr()
    |   LOOKAHEAD(2)
        inExpr()
    |   binaryEqualityExpr()
    )* 
}

void unaryEqualityExpr() :
{}
{
    (
        "ISNULL" 
    |   "NOTNULL" 
    |   "NOT" "NULL" 
    ) 
}

void binaryEqualityExpr() :
{}
{
    binaryEqualityOperator()
    relationalExpr() 
}

void  binaryEqualityOperator() :
{
}
{
    "=" 
|   "==" 
|   "!=" 
|   "<>" 
|   "IS"
    [
        "NOT" 
    ] 
|   "NOT"
    (
        "LIKE" 
    |   "GLOB" 
    |   "REGEXP" 
    |   "MATCH" 
    )
|   "LIKE" 
|   "GLOB" 
|   "REGEXP" 
|   "MATCH" 
}

void betweenExpr() :
{}
{
    (
        "NOT" "BETWEEN" 
    |   "BETWEEN" 
    )
     relationalExpr()
    "AND"
     relationalExpr() 
}

void inExpr() :
{}
{
    (
        "NOT" "IN" 
    |   "IN" 
    )
    (
        "("
        (
             inSelectExpr()
        |    inSetExpr()
        )
        ")"
    |    inTableExpr()
    ) 
}

void inSelectExpr() :
{}
{
     selectStmt() 
}

void inSetExpr() :
{}
{
    [
	     expr() 
	    (
	        ","
	         expr() 
	    )*
    ] 
}

void inTableExpr() :
{}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
   		 name()
        "."
    ]
     name()
}

void relationalExpr() :
{}
{
     escapeExpr()
    (
        (
            "<" 
        |   "<=" 
        |   ">" 
        |   ">=" 
        )
        escapeExpr() 
    )* 
}

void escapeExpr() :
{}
{
     bitwiseExpr()
    [
        "ESCAPE"
        bitwiseExpr() 
    ] 
}

void bitwiseExpr() :
{}
{
     additiveExpr()
    (
        bitwiseOperator()
        additiveExpr() 
    )* 
}

void bitwiseOperator() :
{}
{
    ">>" 
|   "<<" 
|   "&" 
|   "|" 
}

void additiveExpr() :
{}
{
     multiplicativeExpr()
    (
        (
            "+" 
        |   "-" 
        )
       multiplicativeExpr() 
    )* 
}

void multiplicativeExpr() :
{}
{
    concatenateExpr()
    (
        (
            "*" 
        |   "/" 
        |   "%"
        )
         concatenateExpr() 
    )*
}

void concatenateExpr() :
{}
{
    collateExpr()
    (
        "||"
        collateExpr() 
    )* 
}

void collateExpr() :
{}
{
     unaryExpr()
    (
        "COLLATE"
         name() 
    )* 
}

void unaryExpr() :
{}
{
    (   
	     unaryOperator() 
         unaryExpr()
    |    terminalExpr()
    ) 
}

void unaryOperator() :
{}
{
    "-" 
|   "+" 
|   "~" 
}

void terminalExpr() :
{}
{
    (
        bindParameterExpr()
    |   LOOKAHEAD(2) // columnExpr also starts with a name.
        functionExpr()
    |   LOOKAHEAD(2) // literalExpr may also start with a <STRING>.
        columnExpr()
    |   literalExpr()
    |   castExpr()
    |   existsExpr()
    |   LOOKAHEAD(2) // selectExpr also starts by "(".
        "(" expr() ")"
    |   selectExpr()
    |   caseExpr()
    |   raiseFunctionExpr()
    ) 
}

void literalExpr() :
{}
{
     literalValue() 
}

void bindParameterExpr() :
{}
{
    <PARAMETER> 
}

void functionExpr() :
{}
{
     name() 
    "("
    [
        "*" 
    |   [
            "DISTINCT" 
        ]
         expr() 
        (
            ","
             expr() 
        )*
    ]
    ")" 
}

void columnExpr() :
{}
{
    (
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
        [
            LOOKAHEAD(4) // Anticipate the occurrence of a dot.
          name() 
            "."
        ]
        name() 
        "."    
	    name() 
    |   <ID> 
    )
}

void castExpr() :
{}
{
    "CAST" 
    "("
     expr()
    "AS"
    typeName()
    ")" 
}

void existsExpr() :
{}
{
    "EXISTS" 
     selectExpr() 
}

void selectExpr() :
{}
{
    "(" 
       selectStmt()
    ")" 
}

void caseExpr() :
{}
{
    "CASE" 
    [
       expr()
    ]
    (
           whenExpr() 
    )+
    [
        "ELSE"
        expr()
    ]
    "END" 
}

void whenExpr() :
{}
{
    "WHEN" 
     expr()
    "THEN"
      expr() 
}

void raiseFunctionExpr() :
{}
{
    "RAISE" 
    "("
    (
        "IGNORE" 
    |   (
            "ROLLBACK" 
        |   "ABORT" 
        |   "FAIL" 
        )
        ","
        (
            <ID>
        |   <STRING>
        ) 
    )
    ")" 
}

void literalValue() :
{}
{
    (
         numericLiteral()
    |    stringLiteral()
    |    blobLiteral()
    |   (
            "NULL"
        |   "CURRENT_TIME"
        |   "CURRENT_DATE"
        |   "CURRENT_TIMESTAMP"
        )
    ) 
}

void numericLiteral() :
{}
{
    <NUMERIC> 
}

void stringLiteral() :
{
}
{
   <STRING> 
}

void blobLiteral() :
{
}
{
    <BLOB> 
}

void insertStmt() :
{}
{
    (
        "INSERT" 
        [
            "OR"
            (
                "ROLLBACK" 
            |   "ABORT" 
            |   "REPLACE" 
            |   "FAIL" 
            |   "IGNORE" 
            )
        ]
    |   "REPLACE"
    )
    "INTO"
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() "."
    ]
     name()
    (
        "DEFAULT" "VALUES"
    |   [
            "(" 
            name() 
            (
                ","
	             name() 
            )*
            ")"
        ]
        (
             insertStmtWithValues()
        |    insertStmtWithSelect()
        )
    ) 
}

void insertStmtWithValues() :
{}
{
    "VALUES"
    "("
      expr()
    (
        ","
	      expr() 
    )*
    ")" 
    (
        "," 
        "("
         expr()
	    (
	        ","
	        expr() 
	    )*
        ")" 
    )* 
}
        
void insertStmtWithSelect() :
{}
{
     selectStmt()
}

void pragmaStmt() :
{}
{
    "PRAGMA" 
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
       name() "."
    ]
     name()
    [
        "="
       pragmaValue()
    |   "("
        pragmaValue()
        ")"
    ] 
}

void pragmaValue() :
{}
{
    (
        signedNumber() 
    |   LOOKAHEAD(<STRING>) // name() that also can match <STRING>
        stringLiteral() 
    |   name() 
	)
}

void reindexStmt() :
{}
{
    "REINDEX" 
    [
        name()
        [
            "."
            name()
        ]
    ] 
}

void selectStmt() :
{}
{
     selectCore()
    (
        compoundOperator()
         selectCore() 
    )* 
    eventConstraint() 
}

void selectCore() :
{}
{
    "SELECT" 
    [
        "DISTINCT" |   "ALL" 
    ]
    resultColumn() ( "," resultColumn())* "FROM" joinSource()
    
    [
        "WHERE"
        expr()
    ]
    [
        "GROUP" "BY" 
         expr() 
        (
            ","
             expr() 
        )*
        [
            "HAVING"
            expr()
        ]
    ] 
}

void resultColumn() :
{}
{
    (
        LOOKAHEAD(3) // Removes ambiguity between "table.*" and "table.column".
        universalColumn()
    |   expressionColumn()
    ) 
}

void universalColumn() :
{}
{
    (
        "*" 
    |  name()
        "." 
        "*" 
    )
}

void expressionColumn() :
{}
{
    expr()
    [
       aliasedColumn()
    ] 
}

void aliasedColumn() :
{}
{
	[
		"AS" 
	]
	 name() 
}

void joinSource() :
{}
{
    singleSource()
    (
        joinOp()
        singleSource()
        joinConstraint() 
    )* 
}

void singleSource() :
{}
{
    (
        tableSource()
    |   // To remove ambiguity between selectSource and the joinSource because 
        // both start by "(".
        LOOKAHEAD(2)
        selectSource()
    |   "(" 
        joinSource()
        ")" 
    ) 
}

void tableSource() :
{}
{
    [
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() 
        "."
    ]
     name() 
    [
        [ "AS" ]
         name()
    ]
    indexedBy()
   }

void selectSource() :
{}
{
    "(" 
    	 selectStmt()
    ")"
    [
        [ "AS" ]
         name()
    ]
 }

void joinOp() :
{
}
{
    "," 
|   "NATURAL" 
    (
        "LEFT" 
        (
            "OUTER" "JOIN" 
	    |   "JOIN" 
        )
    |   "INNER" "JOIN" 
    |   "CROSS" "JOIN" 
    |   "JOIN" 
    )
|   "LEFT" 
    (
        "OUTER" "JOIN" 
    |   "JOIN" 
    )
|   "INNER" "JOIN" 
|   "CROSS" "JOIN" 
|   "JOIN" 
}

void joinConstraint() :
{}
{
    [
        joinConstraintOn()
    |   joinConstraintUsing()
    ] 
}

void joinConstraintOn() :
{}
{
    "ON" 
    expr() 
}

void joinConstraintUsing():
{}
{
    "USING" 
	"("
     name() 
    (
        ","
         name() 
    )*
    ")" 
}

void orderingTerm() :
{}
{
     expr() 
    [
        "ASC" 
    |   "DESC"
    ] }

void compoundOperator() :
{}
{
    "UNION" 
    [ 
        "ALL" 
    ] 
|   "INTERSECT" 
|   "EXCEPT" 
}

void indexedBy() :
{}
{
    [
	    (
	        "INDEXED" 
            "BY"
	         name()
	    |   "NOT" 
            "INDEXED"
	    ) 
    ]
}

void updateStmt() :
{
}
{
    "UPDATE" 
    [
        "OR"
        (
            "ROLLBACK" 
        |   "ABORT" 
        |   "REPLACE" 
        |   "FAIL" 
        |   "IGNORE" 
        )
    ]
     qualifiedTableName()
    "SET"
       columnAssignment() 
    (
        ","
	    columnAssignment() 
    )*
    [
        "WHERE"
         expr()
    ]
    eventConstraint() 
}

void qualifiedTableName() :
{}
{
    [   
        LOOKAHEAD(2) // Anticipate the occurrence of a dot.
         name() 
        "."
    ]
     name() 
     indexedBy() 
}

void columnAssignment() :
{}
{
     name()
    "="
     expr() 
}


void vacuumStmt() :
{
}
{
    "VACUUM" 
}